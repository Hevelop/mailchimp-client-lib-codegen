=begin
{{> api_info}}
=end

require 'json'
require 'faraday'

module {{moduleName}}
  class ApiClient
    # Defines the headers to be used in HTTP requests of all API calls by default.
    #
    # @return [Hash]
    attr_accessor :default_headers

    # Initializes the ApiClient
    def initialize(api_key, server = '')
      @host = "{{{basePath}}}"
      @user_agent = "{{#httpUserAgent}}{{{.}}}{{/httpUserAgent}}{{^httpUserAgent}}Swagger-Codegen/#{VERSION}/ruby{{/httpUserAgent}}"
      @default_headers = {
        'Content-Type' => 'application/json',
        'User-Agent' => @user_agent
      }

      @api_key = api_key
      @server = server || get_server_from_api_key(api_key)
    end

    def self.default
      @@default ||= ApiClient.new
    end

    def get_server_from_api_key(api_key = '')
      begin
        split = api_key.split('-us', 1)
        server_prefix = 'us'
        server = server_prefix + api_key.split('-' + server_prefix, 1)[1]
        server
      rescue
        ""
      end
    end

    def set_config(api_key = '', server = '')
      @api_key = api_key || @api_key
      @server = server || get_server_from_api_key(api_key) || @server
    end

    def call_api(http_method, path, opts = {})
      header_params = @default_headers.merge(opts[:header_params] || {})
      query_params = opts[:query_params] || {}
      form_params = opts[:form_params] || {}

      body = {}
      if [:post, :patch, :put, :delete].include?(http_method.to_sym.downcase)
        body = build_request_body(header_params, form_params, opts[:body])
      end

      res = request(http_method, path, query_params, header_params, body)

      data = nil
      if res.headers['content-type'] && res.headers['content-type'].include?('application/json')
        data = JSON.parse(res.body)
      else
        data = res.body
      end

      if data
        if res.status <= 200
          data
        else
          fail ApiError.new(res.body)
        end
      end
    end

    def request(http_method, path, query_params = nil, header_params = nil, body = nil)
      host = @server.length > 0 ? @host.sub('server', @server) : @host
      url = host + path

      conn = Faraday.new(url) do |conn|
        conn.params = query_params
        conn.headers = header_params
        conn.basic_auth('user', @api_key)
      end

      case http_method.to_sym.downcase
      when :delete
        conn.delete do |req|
          req.body = body.to_json
        end
      when :get
        conn.get
      when :head
        conn.head
      when :options
        conn.options
      when :post
        conn.post do |req|
          req.body = body.to_json
        end
      when :put
        conn.put do |req|
          req.body = body.to_json
        end
      when :patch
        conn.patch do |req|
          req.body = body.to_json
        end
      else
        fail ApiError.new('Invalid http_method')
      end
    end

    # Sanitize filename by removing path.
    # e.g. ../../sun.gif becomes sun.gif
    #
    # @param [String] filename the filename to be sanitized
    # @return [String] the sanitized filename
    def sanitize_filename(filename)
      filename.gsub(/.*[\/\\]/, '')
    end

    def build_request_url(path)
      # Add leading and trailing slashes to path
      path = "/#{path}".gsub(/\/+/, '/')
      URI.encode(@config.base_url + path)
    end

    # Builds the HTTP request body
    #
    # @param [Hash] header_params Header parameters
    # @param [Hash] form_params Query parameters
    # @param [Object] body HTTP body (JSON/XML)
    # @return [String] HTTP body data in the form of string
    def build_request_body(header_params, form_params, body)
      # http form
      if header_params['Content-Type'] == 'application/x-www-form-urlencoded' ||
          header_params['Content-Type'] == 'multipart/form-data'
        data = {}
        form_params.each do |key, value|
          case value
          when ::File, ::Array, nil
            # let typhoeus handle File, Array and nil parameters
            data[key] = value
          else
            data[key] = value.to_s
          end
        end
      elsif body
        data = body.is_a?(String) ? body : body.to_json
      else
        data = nil
      end
      data
    end

    # Return Accept header based on an array of accepts provided.
    # @param [Array] accepts array for Accept
    # @return [String] the Accept header (e.g. application/json)
    def select_header_accept(accepts)
      return nil if accepts.nil? || accepts.empty?
      # use JSON when present, otherwise use all of the provided
      json_accept = accepts.find { |s| json_mime?(s) }
      json_accept || accepts.join(',')
    end

    # Return Content-Type header based on an array of content types provided.
    # @param [Array] content_types array for Content-Type
    # @return [String] the Content-Type header  (e.g. application/json)
    def select_header_content_type(content_types)
      # use application/json by default
      return 'application/json' if content_types.nil? || content_types.empty?
      # use JSON when present, otherwise use the first one
      json_content_type = content_types.find { |s| json_mime?(s) }
      json_content_type || content_types.first
    end

    # Convert object (array, hash, object, etc) to JSON string.
    # @param [Object] model object to be converted into JSON string
    # @return [String] JSON string representation of the object
    def object_to_http_body(model)
      return model if model.nil? || model.is_a?(String)
      local_body = nil
      if model.is_a?(Array)
        local_body = model.map { |m| object_to_hash(m) }
      else
        local_body = object_to_hash(model)
      end
      local_body.to_json
    end

    # Convert object(non-array) to hash.
    # @param [Object] obj object to be converted into JSON string
    # @return [String] JSON string representation of the object
    def object_to_hash(obj)
      if obj.respond_to?(:to_hash)
        obj.to_hash
      else
        obj
      end
    end

    # Build parameter value according to the given collection format.
    # @param [String] collection_format one of :csv, :ssv, :tsv, :pipes and :multi
    def build_collection_param(param, collection_format)
      case collection_format
      when :csv
        param.join(',')
      when :ssv
        param.join(' ')
      when :tsv
        param.join("\t")
      when :pipes
        param.join('|')
      when :multi
        # return the array directly as typhoeus will handle it as expected
        param
      else
        fail "unknown collection format: #{collection_format.inspect}"
      end
    end

    # Check if the given MIME is a JSON MIME.
    # JSON MIME examples:
    #   application/json
    #   application/json; charset=UTF8
    #   APPLICATION/JSON
    #   */*
    # @param [String] mime MIME
    # @return [Boolean] True if the MIME is application/json
    def json_mime?(mime)
      (mime == '*/*') || !(mime =~ /Application\/.*json(?!p)(;.*)?/i).nil?
    end
  end
end
